<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>水波干涉模拟</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            mix-blend-mode: difference;
        }
    </style>
</head>

<body>

    <div class="ui">
        <h1 class="text-2xl font-bold">Ripple Tank</h1>
        <p class="text-xs opacity-70">Click or Drag to create waves</p>
    </div>

    <div class="absolute bottom-8 left-1/2 -translate-x-1/2 flex gap-4 pointer-events-none">
        <button onclick="rain()"
            class="pointer-events-auto bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-full backdrop-blur border border-white/20 text-xs font-bold transition">Rain
            Mode</button>
        <button onclick="reset()"
            class="pointer-events-auto bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-full backdrop-blur border border-white/20 text-xs font-bold transition">Clear</button>
        <a href="./navigation.html"
            class="pointer-events-auto bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-full backdrop-blur border border-white/20 text-xs font-bold transition">Exit</a>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        // Algorithm: Dampened wave equation
        // 2 buffers: current and previous state
        let buffer1, buffer2;
        let cols, rows;
        const damping = 0.98; // Energy loss
        let isRaining = false;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;

            // Resolution (downscale for performance)
            const scale = 2; // 1 pixel = 2 screen pixels
            cols = Math.floor(width / scale);
            rows = Math.floor(height / scale);

            canvas.width = cols;
            canvas.height = rows;

            buffer1 = new Float32Array(cols * rows);
            buffer2 = new Float32Array(cols * rows);
        }
        window.addEventListener('resize', resize);
        resize();

        function update() {
            // Swap buffers
            const temp = buffer1;
            buffer1 = buffer2;
            buffer2 = temp;

            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < rows - 1; j++) {
                    const idx = j * cols + i;

                    // Wave propagation: average of neighbors * 2 - previous state
                    const val = (
                        buffer1[idx - 1] +
                        buffer1[idx + 1] +
                        buffer1[idx - cols] +
                        buffer1[idx + cols]
                    ) / 2 - buffer2[idx];

                    buffer2[idx] = val * damping;
                }
            }

            // Rain
            if (isRaining && Math.random() > 0.9) {
                const x = Math.floor(Math.random() * (cols - 2)) + 1;
                const y = Math.floor(Math.random() * (rows - 2)) + 1;
                buffer1[y * cols + x] = 255;
            }
        }

        function draw() {
            const imageData = ctx.getImageData(0, 0, cols, rows);
            const data = imageData.data;

            for (let i = 0; i < cols * rows; i++) {
                // Map wave height (-255 to 255) to color
                let val = buffer2[i];

                // Visualization: Blue-ish tint
                // Base blue 50, + val
                // Peaks are white/cyan, troughs are dark blue

                // Clamp
                // val can be negative or positive

                const idx = i * 4;

                // Water shader effect
                // Positive val = light (crest), Negative = dark (trough)

                const brightness = 128 + val;

                data[idx] = brightness * 0.1; // R (Dark)
                data[idx + 1] = brightness * 0.5 + 50; // G (Cyan ish)
                data[idx + 2] = brightness + 100; // B (Blue)
                data[idx + 3] = 255; // Alpha
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function disturb(x, y, amount) {
            // Map screen x,y to grid
            const rect = canvas.getBoundingClientRect();
            // Since canvas is scaled via CSS (width=100%), but internal res is smaller
            // But here canvas.width IS the internal res.
            // Screen pixel ratio?
            // Simple map:
            const cx = Math.floor(x / window.innerWidth * cols);
            const cy = Math.floor(y / window.innerHeight * rows);

            if (cx > 1 && cx < cols - 1 && cy > 1 && cy < rows - 1) {
                buffer1[cy * cols + cx] += amount;
                // Add radius for visibility
                buffer1[cy * cols + cx + 1] += amount / 2;
                buffer1[cy * cols + cx - 1] += amount / 2;
                buffer1[(cy + 1) * cols + cx] += amount / 2;
                buffer1[(cy - 1) * cols + cx] += amount / 2;
            }
        }

        function reset() {
            buffer1.fill(0);
            buffer2.fill(0);
            isRaining = false;
        }

        function rain() {
            isRaining = !isRaining;
        }

        // Input
        let isDown = false;
        window.addEventListener('mousedown', e => {
            isDown = true;
            disturb(e.clientX, e.clientY, 500);
        });
        window.addEventListener('mousemove', e => {
            if (isDown) disturb(e.clientX, e.clientY, 200);
        });
        window.addEventListener('mouseup', () => isDown = false);

        window.addEventListener('touchstart', e => {
            isDown = true;
            disturb(e.touches[0].clientX, e.touches[0].clientY, 500);
        });
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            disturb(e.touches[0].clientX, e.touches[0].clientY, 200);
        });
        window.addEventListener('touchend', () => isDown = false);

        loop();
    </script>
</body>

</html>