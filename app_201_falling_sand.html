<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理沙盘</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            image-rendering: pixelated;
            cursor: crosshair;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        .tool-btn.active {
            border-color: white;
            box-shadow: 0 0 0 2px #3b82f6;
        }
    </style>
</head>

<body class="bg-slate-900 min-h-screen flex flex-col items-center justify-center p-4 touch-none select-none">

    <div class="mb-4 text-center">
        <h1 class="text-2xl font-bold text-white mb-2">Falling Sand</h1>
        <p class="text-xs text-slate-400">选择元素，在画布上涂鸦</p>
    </div>

    <canvas id="canvas" class="bg-black rounded-lg border-4 border-slate-700 mb-6"></canvas>

    <div class="flex flex-wrap gap-4 justify-center bg-slate-800 p-4 rounded-xl border border-slate-700">

        <button onclick="setTool(1)" id="btn-sand"
            class="tool-btn active w-12 h-12 rounded bg-yellow-500 border-2 border-transparent hover:scale-105 transition"
            title="Sand"></button>
        <button onclick="setTool(2)" id="btn-water"
            class="tool-btn w-12 h-12 rounded bg-blue-500 border-2 border-transparent hover:scale-105 transition"
            title="Water"></button>
        <button onclick="setTool(3)" id="btn-stone"
            class="tool-btn w-12 h-12 rounded bg-gray-500 border-2 border-transparent hover:scale-105 transition"
            title="Stone"></button>
        <button onclick="setTool(0)" id="btn-eraser"
            class="tool-btn w-12 h-12 rounded bg-black border-2 border-slate-500 hover:scale-105 transition flex items-center justify-center text-white text-xs font-bold"
            title="Eraser">X</button>

        <div class="w-px h-12 bg-slate-600 mx-2"></div>

        <button onclick="clearCanvas()"
            class="px-4 py-2 bg-red-600 hover:bg-red-500 text-white font-bold rounded text-xs transition">清空</button>

    </div>

    <div class="mt-4 text-center">
        <a href="./navigation.html" class="text-xs text-slate-500 hover:text-white">退出</a>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Sim resolution
        const width = 100;
        const height = 100;
        const scale = 3; // Visual scale handled by CSS size vs canvas dims? 
        // Let's keep internal logic 100x100, display bigger
        canvas.width = width;
        canvas.height = height;
        canvas.style.width = (width * 4) + 'px';
        canvas.style.height = (height * 4) + 'px';

        let grid = new Array(width * height).fill(0); // 0=Empty, 1=Sand, 2=Water, 3=Stone
        let currentTool = 1;
        let isDrawing = false;

        // Colors
        const colors = {
            0: [0, 0, 0],       // Black
            1: [234, 179, 8],   // Yellow-500
            2: [59, 130, 246],  // Blue-500
            3: [107, 114, 128]  // Gray-500
        };

        function setTool(type) {
            currentTool = type;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const id = type === 0 ? 'eraser' : (type === 1 ? 'sand' : (type === 2 ? 'water' : 'stone'));
            document.getElementById(`btn-${id}`).classList.add('active');
        }

        function clearCanvas() {
            grid.fill(0);
        }

        function draw() {
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            for (let i = 0; i < grid.length; i++) {
                const type = grid[i];
                const col = colors[type];
                const idx = i * 4;
                data[idx] = col[0];
                data[idx + 1] = col[1];
                data[idx + 2] = col[2];
                data[idx + 3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function update() {
            const nextGrid = [...grid];

            // Iterate from bottom up
            for (let y = height - 1; y >= 0; y--) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const type = grid[idx];

                    if (type === 1) { // Sand
                        const below = (y + 1) * width + x;
                        const belowLeft = (y + 1) * width + (x - 1);
                        const belowRight = (y + 1) * width + (x + 1);

                        if (y + 1 < height && grid[below] === 0) {
                            next[idx] = 0;
                            next[below] = 1;
                        } else if (y + 1 < height && grid[below] === 2) {
                            // Sink in water
                            next[idx] = 2;
                            next[below] = 1;
                        } else if (y + 1 < height && x > 0 && grid[belowLeft] === 0) {
                            next[idx] = 0;
                            next[belowLeft] = 1;
                        } else if (y + 1 < height && x < width - 1 && grid[belowRight] === 0) {
                            next[idx] = 0;
                            next[belowRight] = 1;
                        }
                    } else if (type === 2) { // Water
                        const below = (y + 1) * width + x;
                        const left = y * width + (x - 1);
                        const right = y * width + (x + 1);

                        if (y + 1 < height && grid[below] === 0) {
                            next[idx] = 0;
                            next[below] = 2;
                        } else {
                            // Spread horizontal
                            const moveLeft = x > 0 && grid[left] === 0;
                            const moveRight = x < width - 1 && grid[right] === 0;

                            if (moveLeft && moveRight) {
                                next[idx] = 0;
                                next[Math.random() > 0.5 ? left : right] = 2;
                            } else if (moveLeft) {
                                next[idx] = 0;
                                next[left] = 2;
                            } else if (moveRight) {
                                next[idx] = 0;
                                next[right] = 2;
                            }
                        }
                    }
                }
            }
            grid = next;
            draw();
            requestAnimationFrame(update);
        }

        // Input
        function handleInput(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            // Get coordinates relative to canvas
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const x = Math.floor((clientX - rect.left) / (rect.width / width));
            const y = Math.floor((clientY - rect.top) / (rect.height / height));

            // Brush size
            const r = 2;
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        // Only replace empty if painting, or replace anything if erasing/stone
                        // Sand shouldn't delete stone
                        // Keep it simple: overwrite
                        if (Math.random() > 0.2) { // Add some noise to brush
                            grid[ny * width + nx] = currentTool;
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', e => { isDrawing = true; handleInput(e); });
        window.addEventListener('mouseup', () => isDrawing = false);
        window.addEventListener('mousemove', handleInput);

        canvas.addEventListener('touchstart', e => { isDrawing = true; handleInput(e); });
        window.addEventListener('touchend', () => isDrawing = false);
        window.addEventListener('touchmove', handleInput);

        update();
    </script>
</body>

</html>