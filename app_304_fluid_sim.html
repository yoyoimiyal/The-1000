<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流体涂鸦</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui {
            pointer-events: none;
            mix-blend-mode: difference;
        }
    </style>
</head>

<body>

    <div class="absolute top-4 left-4 z-10 text-white ui">
        <h1 class="text-2xl font-bold">Fluid Paint</h1>
        <p class="text-xs opacity-70">Move Mouse to Stir</p>
    </div>

    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 z-10">
        <a href="./navigation.html"
            class="pointer-events-auto bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-full backdrop-blur border border-white/20 text-xs font-bold transition">Exit</a>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // Simple Euler Fluid Simulation
        // Adapted for single file efficiency

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // Sim Grid
        const scale = 8;
        let cols, rows;
        let particles = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cols = Math.ceil(width / scale);
            rows = Math.ceil(height / scale);
            // Re-init particles to fill screen
            particles = [];
            for (let i = 0; i < 3000; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: 0,
                    vy: 0,
                    color: `hsl(${Math.random() * 60 + 200}, 100%, 50%)`, // Blue/Cyan theme
                    age: Math.random() * 100
                });
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // Mouse interaction
        let mouse = { x: 0, y: 0, px: 0, py: 0, down: false };
        window.addEventListener('mousemove', e => {
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            // Add velocity influence
            const dx = mouse.x - mouse.px;
            const dy = mouse.y - mouse.py;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
                // Affect particles near mouse
                for (let p of particles) {
                    const pdx = p.x - mouse.x;
                    const pdy = p.y - mouse.y;
                    const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                    if (pdist < 100) {
                        const force = (100 - pdist) / 100;
                        p.vx += dx * force * 0.2;
                        p.vy += dy * force * 0.2;
                    }
                }
            }
        });

        function loop() {
            // Fade background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Update & Draw Particles
            for (let p of particles) {
                // Simple fluid drag / damping
                p.vx *= 0.96;
                p.vy *= 0.96;

                p.x += p.vx;
                p.y += p.vy;

                // Color cycle
                p.age++;
                const hue = (p.age * 2) % 360;
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;

                // Wrap
                if (p.x < 0) p.x = width;
                if (p.x > width) p.x = 0;
                if (p.y < 0) p.y = height;
                if (p.y > height) p.y = 0;

                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.min(Math.abs(p.vx) + Math.abs(p.vy) + 2, 6), 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>

</html>