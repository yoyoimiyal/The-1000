<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* 寻路算法演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-container {
            display: grid;
            gap: 1px;
            background-color: #e5e7eb;
            border: 1px solid #d1d5db;
        }

        .cell {
            width: 20px;
            height: 20px;
            background-color: white;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .cell.wall {
            background-color: #1f2937;
        }

        /* Gray-800 */
        .cell.start {
            background-color: #22c55e;
        }

        /* Green-500 */
        .cell.end {
            background-color: #ef4444;
        }

        /* Red-500 */
        .cell.open {
            background-color: #bfdbfe;
        }

        /* Blue-200 */
        .cell.closed {
            background-color: #e2e8f0;
        }

        /* Slate-200 */
        .cell.path {
            background-color: #f59e0b;
        }

        /* Yellow-500 */
    </style>
</head>

<body class="bg-slate-50 min-h-screen flex flex-col items-center justify-center p-4 select-none">

    <header class="mb-6 flex justify-between w-full max-w-lg items-center">
        <h1 class="text-xl font-bold text-slate-800">A* Pathfinding</h1>
        <div class="flex gap-2">
            <button onclick="resetGrid()"
                class="text-xs bg-white border border-slate-300 px-3 py-1 rounded hover:bg-slate-50">Reset</button>
            <a href="./navigation.html" class="text-xs text-slate-400 hover:text-slate-600 px-2 py-1">Exit</a>
        </div>
    </header>

    <div class="bg-white p-4 rounded-xl shadow-lg mb-6">
        <div id="grid" class="grid-container">
            <!-- Cells injected -->
        </div>
    </div>

    <div class="flex gap-4 mb-6">
        <button onclick="startSearch()" id="btn-start"
            class="bg-indigo-600 hover:bg-indigo-700 text-white px-8 py-2 rounded-lg font-bold shadow transition">开始寻路</button>
    </div>

    <div class="flex gap-4 text-xs text-slate-500">
        <div class="flex items-center gap-1">
            <div class="w-3 h-3 bg-green-500"></div> Start
        </div>
        <div class="flex items-center gap-1">
            <div class="w-3 h-3 bg-red-500"></div> End
        </div>
        <div class="flex items-center gap-1">
            <div class="w-3 h-3 bg-gray-800"></div> Wall (Click/Drag)
        </div>
    </div>

    <script>
        const cols = 25;
        const rows = 25;
        const gridEl = document.getElementById('grid');
        let grid = [];
        let start = { x: 2, y: 12 };
        let end = { x: 22, y: 12 };
        let isDrawing = false;
        let isSearching = false;

        function init() {
            gridEl.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
            createGrid();
        }

        function createGrid() {
            gridEl.innerHTML = '';
            grid = new Array(cols).fill(0).map(() => new Array(rows).fill(null));

            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    // Mark visual
                    if (x === start.x && y === start.y) cell.classList.add('start');
                    else if (x === end.x && y === end.y) cell.classList.add('end');

                    // Interaction
                    cell.onmousedown = () => { isDrawing = true; toggleWall(x, y, cell); };
                    cell.onmouseenter = () => { if (isDrawing) toggleWall(x, y, cell); };

                    grid[x][y] = { x, y, f: 0, g: 0, h: 0, neighbors: [], previous: undefined, wall: false, el: cell };
                    gridEl.appendChild(cell);
                }
            }

            // Neighbors
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    addNeighbors(grid[x][y]);
                }
            }
        }

        function addNeighbors(node) {
            const x = node.x;
            const y = node.y;
            if (x < cols - 1) node.neighbors.push(grid[x + 1][y]);
            if (x > 0) node.neighbors.push(grid[x - 1][y]);
            if (y < rows - 1) node.neighbors.push(grid[x][y + 1]);
            if (y > 0) node.neighbors.push(grid[x][y - 1]);
            // Diagonals? Let's stick to Manhattan (4-way) for simplicity
        }

        function toggleWall(x, y, el) {
            if (isSearching) return;
            if ((x === start.x && y === start.y) || (x === end.x && y === end.y)) return;

            grid[x][y].wall = !grid[x][y].wall;
            if (grid[x][y].wall) el.classList.add('wall');
            else el.classList.remove('wall');
        }

        window.onmouseup = () => isDrawing = false;

        async function startSearch() {
            if (isSearching) return;
            isSearching = true;

            // Clear previous path
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    const cell = grid[x][y];
                    cell.el.classList.remove('open', 'closed', 'path');
                    cell.previous = undefined;
                    cell.g = 0; cell.h = 0; cell.f = 0;
                }
            }

            let openSet = [grid[start.x][start.y]];
            let closedSet = [];

            while (openSet.length > 0) {
                // Find lowest F
                let winner = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[winner].f) {
                        winner = i;
                    }
                }
                let current = openSet[winner];

                if (current.x === end.x && current.y === end.y) {
                    reconstructPath(current);
                    isSearching = false;
                    return;
                }

                openSet = openSet.filter(n => n !== current);
                closedSet.push(current);

                if (current !== grid[start.x][start.y]) current.el.classList.add('closed');

                for (let neighbor of current.neighbors) {
                    if (!closedSet.includes(neighbor) && !neighbor.wall) {
                        const tempG = current.g + 1;
                        let newPath = false;

                        if (openSet.includes(neighbor)) {
                            if (tempG < neighbor.g) {
                                neighbor.g = tempG;
                                newPath = true;
                            }
                        } else {
                            neighbor.g = tempG;
                            newPath = true;
                            openSet.push(neighbor);
                            if (neighbor !== grid[end.x][end.y]) neighbor.el.classList.add('open');
                        }

                        if (newPath) {
                            neighbor.h = heuristic(neighbor, grid[end.x][end.y]);
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.previous = current;
                        }
                    }
                }

                await new Promise(r => setTimeout(r, 20)); // Visualize delay
            }

            alert("无路可走!");
            isSearching = false;
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function reconstructPath(current) {
            let temp = current;
            while (temp.previous) {
                if (temp !== grid[end.x][end.y]) temp.el.classList.add('path');
                temp = temp.previous;
                // await new Promise(r => setTimeout(r, 10)); // Anim path
            }
        }

        function resetGrid() {
            if (isSearching) return;
            createGrid();
        }

        init();
    </script>
</body>

</html>